#include <iostream>
#include <vector>
#include <fstream>
#include <iomanip> // For std::setprecision
#include <cmath>   // For std::pow
#include <string>

class Transaction {
protected:
    double amount;
    std::string description;

public:
    Transaction(double amt, const std::string& desc) : amount(amt), description(desc) {}
    virtual double getAmount() const { return amount; }
    virtual std::string getDescription() const { return description; }
};

class Income : public Transaction {
public:
    Income(double amt, const std::string& desc) : Transaction(amt, desc) {}
};

class Expenditure : public Transaction {
public:
    Expenditure(double amt, const std::string& desc) : Transaction(amt, desc) {}
};

class Investment {
protected:
    double amount;
    int duration; // in years

public:
    Investment(double amt, int dur) : amount(amt), duration(dur) {}
    virtual double calculateReturns(double interestRate) const = 0; // Pure virtual function
    double getAmount() const { return amount; }
    int getDuration() const { return duration; }
};

class SIP : public Investment {
public:
    SIP(double amt, int dur) : Investment(amt, dur) {}
    double calculateReturns(double interestRate) const override {
        double total = 0;
        for (int i = 1; i <= duration * 12; ++i) { // duration in years, converting to months
            total += amount * (1 + interestRate / 100) * i;
        }
        return total;
    }
};

class FD : public Investment {
public:
    FD(double amt, int dur) : Investment(amt, dur) {}
    double calculateReturns(double interestRate) const override {
        return amount * std::pow((1 + interestRate / 100), duration); // Annual compounding
    }
};

class FinanceManager {
private:
    std::vector<Transaction*> transactions;
    std::vector<Investment*> investments;
    double balance;

public:
    FinanceManager() : balance(0) {}

    void addIncome(double amount, const std::string& description) {
        transactions.push_back(new Income(amount, description));
        balance += amount;
    }

    void addExpenditure(double amount, const std::string& description) {
        transactions.push_back(new Expenditure(amount, description));
        balance -= amount;
    }

    void addInvestment(Investment* investment) {
        investments.push_back(investment);
    }

    void generateHTMLReport() {
        std::ofstream htmlFile("finance_report.html");

        htmlFile << "<!DOCTYPE html><html lang='en'><head>";
        htmlFile << "<meta charset='UTF-8'><meta name='viewport' content='width=device-width, initial-scale=1.0'>";
        htmlFile << "<title>Personal Finance Report</title>";
        htmlFile << "<link rel='stylesheet' href='style.css'></head><body>";
        htmlFile << "<div class='container'><header><h1>Personal Finance Report</h1><p>Summary of your expenses and income</p></header>";
        htmlFile << "<section class='summary'><h2>Monthly Summary</h2>";
        htmlFile << "<table><tr><th>Category</th><th>Amount</th></tr>";
        htmlFile << "<tr><td>Total Balance</td><td>" << std::fixed << std::setprecision(2) << balance << "</td></tr></table></section>";

        // Savings section
        htmlFile << "<section class='expenses'><h2>Savings & Expenditures</h2><table>";
        htmlFile << "<tr><th>Type</th><th>Amount</th><th>Description</th></tr>";
        for (const auto& transaction : transactions) {
            htmlFile << "<tr><td>" << (dynamic_cast<Income*>(transaction) ? "Income" : "Expenditure") << "</td>";
            htmlFile << "<td>" << transaction->getAmount() << "</td><td>" << transaction->getDescription() << "</td></tr>";
        }
        htmlFile << "</table></section>";

        // Investments section
        htmlFile << "<section class='investments'><h2>Investments</h2><table>";
        htmlFile << "<tr><th>Type</th><th>Amount</th><th>Duration (Years)</th><th>Returns</th></tr>";
        for (const auto& investment : investments) {
            double interestRate = 0.0; // Assume this is set appropriately
            htmlFile << "<tr><td>" << (dynamic_cast<SIP*>(investment) ? "SIP" : "FD") << "</td>";
            htmlFile << "<td>" << investment->getAmount() << "</td><td>" << investment->getDuration() << "</td>";
            htmlFile << "<td>" << investment->calculateReturns(interestRate) << "</td></tr>";
        }
        htmlFile << "</table></section>";

        htmlFile << "<footer><p>Generated by the Personal Finance Tracker</p></footer>";
        htmlFile << "</div></body></html>";
        htmlFile.close();
    }

    void displayRecord() {
        generateHTMLReport();
        std::cout << "HTML Report generated: open finance_report.html to view.\n";
    }

    // Added functions to access private members
    const std::vector<Transaction*>& getTransactions() const {
        return transactions;
    }

    const std::vector<Investment*>& getInvestments() const {
        return investments;
    }
};

int main() {
    FinanceManager fm;
    
    char continueInput;

    // Loop to input multiple transactions
    do {
        int transactionType;
        std::cout << "Choose transaction type (1 for Income, 2 for Expenditure): ";
        std::cin >> transactionType;

        if (transactionType == 1) {
            double income;
            std::string incomeDescription;
            std::cout << "Enter income amount: ";
            std::cin >> income;
            std::cout << "Enter income description: ";
            std::cin.ignore(); // Clear newline from input buffer
            std::getline(std::cin, incomeDescription);
            fm.addIncome(income, incomeDescription);
        } else if (transactionType == 2) {
            double expenditure;
            std::string expenditureDescription;
            std::cout << "Enter expenditure amount: ";
            std::cin >> expenditure;
            std::cout << "Enter expenditure description: ";
            std::cin.ignore();
            std::getline(std::cin, expenditureDescription);
            fm.addExpenditure(expenditure, expenditureDescription);
        } else {
            std::cout << "Invalid transaction type selected.\n";
            return 1; // Exit if invalid input
        }

        std::cout << "Do you want to add another transaction? (y/n): ";
        std::cin >> continueInput;
    } while (continueInput == 'y' || continueInput == 'Y');

    // User input for investments
    int investmentType;
    do {
        std::cout << "Choose investment type (1 for SIP, 2 for FD, 3 for no investment): ";
        std::cin >> investmentType;

        Investment* investment = nullptr;

        if (investmentType == 1 || investmentType == 2) {
            double investmentAmount;
            int duration;
            std::cout << "Enter investment amount: ";
            std::cin >> investmentAmount;
            std::cout << "Enter investment duration (in years): ";
            std::cin >> duration;

            double interestRate;
            std::cout << "Enter expected annual interest rate (in percentage): ";
            std::cin >> interestRate;

            if (investmentType == 1) {
                investment = new SIP(investmentAmount, duration);
            } else if (investmentType == 2) {
                investment = new FD(investmentAmount, duration);
            }

            if (investment) {
                fm.addInvestment(investment);
            }
        } else if (investmentType != 3) {
            std::cout << "Invalid investment type selected.\n";
            continue; // Skip to next iteration if invalid
        }

        std::cout << "Do you want to add another investment? (y/n): ";
        std::cin >> continueInput;
    } while (continueInput == 'y' || continueInput == 'Y');

    // Option to generate report
    char generateReport;
    std::cout << "Do you want to generate the finance report? (y/n): ";
    std::cin >> generateReport;

    if (generateReport == 'y' || generateReport == 'Y') {
        fm.displayRecord();
    }

    // Clean up dynamic memory (if any)
    for (const auto& transaction : fm.getTransactions()) {
        delete transaction; // Clean up transactions
    }
    for (const auto& inv : fm.getInvestments()) {
        delete inv; // Clean up investments
    }

    return 0;
}
